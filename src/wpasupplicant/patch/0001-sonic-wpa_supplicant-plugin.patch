diff --git a/debian/config/wpasupplicant/linux b/debian/config/wpasupplicant/linux
index 8be0243..05b0315 100644
--- a/debian/config/wpasupplicant/linux
+++ b/debian/config/wpasupplicant/linux
@@ -79,6 +79,9 @@ CONFIG_DRIVER_WIRED=y
 # Driver interface for Linux MACsec drivers
 CONFIG_DRIVER_MACSEC_LINUX=y
 
+# Driver interface for SONiC MACsec drivers
+CONFIG_DRIVER_MACSEC_SONIC=y
+
 # Driver interface for the Broadcom RoboSwitch family
 #CONFIG_DRIVER_ROBOSWITCH=y
 
diff --git a/src/drivers/driver.h b/src/drivers/driver.h
index 2a8459a..1ba5ab8 100644
--- a/src/drivers/driver.h
+++ b/src/drivers/driver.h
@@ -5763,6 +5763,10 @@ extern const struct wpa_driver_ops wpa_driver_macsec_qca_ops;
 /* driver_macsec_linux.c */
 extern const struct wpa_driver_ops wpa_driver_macsec_linux_ops;
 #endif /* CONFIG_DRIVER_MACSEC_LINUX */
+#ifdef CONFIG_DRIVER_MACSEC_SONIC
+/* driver_macsec_sonic.c */
+extern const struct wpa_driver_ops wpa_driver_macsec_sonic_ops;
+#endif /* CONFIG_DRIVER_MACSEC_SONIC */
 #ifdef CONFIG_DRIVER_ROBOSWITCH
 /* driver_roboswitch.c */
 extern const struct wpa_driver_ops wpa_driver_roboswitch_ops;
diff --git a/src/drivers/driver_macsec_sonic.c b/src/drivers/driver_macsec_sonic.c
new file mode 100644
index 0000000..e3426c6
--- /dev/null
+++ b/src/drivers/driver_macsec_sonic.c
@@ -0,0 +1,1000 @@
+/*
+ * Driver interaction with Linux MACsec kernel module
+ * Copyright (c) 2016, Sabrina Dubroca <sd@queasysnail.net> and Red Hat, Inc.
+ * Copyright (c) 2019, The Linux Foundation
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+#include "includes.h"
+
+#include <inttypes.h>
+#include <stdarg.h>
+
+#include <openssl/aes.h>
+
+#include "utils/common.h"
+#include "driver.h"
+#include "driver_wired_common.h"
+#include "sonic_operators.h"
+
+#define DRV_PREFIX "macsec_sonic"
+
+#define LOG_FORMAT(FORMAT, ...) \
+    DRV_PREFIX"(%s) : %s "FORMAT"\n",drv->ifname,__PRETTY_FUNCTION__,__VA_ARGS__
+
+#define STD_PRINT_LOG(FORMAT, ...) \
+    printf(LOG_FORMAT(FORMAT,__VA_ARGS__))
+
+#define WPA_PRINT_LOG(FORMAT, ...) \
+    wpa_printf(MSG_DEBUG, LOG_FORMAT(FORMAT, __VA_ARGS__))
+
+#define PRINT_LOG(FORMAT, ...) \
+    STD_PRINT_LOG(FORMAT, __VA_ARGS__); \
+    WPA_PRINT_LOG(FORMAT, __VA_ARGS__);
+
+#define ENTER_LOG \
+    PRINT_LOG("%s", "")
+
+#define PAIR_EMPTY NULL,0
+#define PAIR_ARRAY(pairs) pairs,(sizeof(pairs)/sizeof(*pairs))
+
+#define DEFAULT_KEY_SEPARATOR  ":"
+#define APP_DB_SEPARATOR       DEFAULT_KEY_SEPARATOR
+#define STATE_DB_SEPARATOR     "|"
+
+static char * create_buffer(const char * fmt, ...)
+{
+    va_list args;
+    va_start(args, fmt);
+    unsigned int length = vsnprintf(NULL, 0, fmt, args) + 1;
+    va_end(args);
+    if (length < 1)
+    {
+        return NULL;
+    }
+    char * buffer = (char *)malloc(length);
+    if (buffer == NULL)
+    {
+        return NULL;
+    }
+    va_start(args, fmt);
+    vsnprintf(buffer, length, fmt, args);
+    va_end(args);
+    return buffer;
+}
+
+#define CREATE_SC_KEY(IFNAME, SC, SEPARATOR)    \
+    create_buffer(                              \
+        "%s"                                    \
+        SEPARATOR "%llu",                       \
+        IFNAME,                                 \
+        mka_sci_u64(&SC->sci))
+
+#define CREATE_SA_KEY(IFNAME, SA, SEPARATOR)    \
+    create_buffer(                              \
+        "%s"                                    \
+        SEPARATOR "%llu"                        \
+        SEPARATOR "%u",                         \
+        IFNAME,                                 \
+        mka_sci_u64(&SA->sc->sci),              \
+        (unsigned int)(SA->an))
+
+static char * create_binary_hex(const void * binary, unsigned long long length)
+{
+    if (binary == NULL || length == 0)
+    {
+        return NULL;
+    }
+    char * buffer = (char *)malloc(2 * length + 1);
+    if (buffer == NULL)
+    {
+        return NULL;
+    }
+    const unsigned char * input = (const unsigned char *)binary;
+    for (unsigned long long i = 0; i < length; i++)
+    {
+        snprintf(&buffer[i * 2], 3, "%02X", input[i]);
+    }
+    return buffer;
+}
+
+static char *create_auth_key(const unsigned char *key, unsigned long long key_length)
+{
+    unsigned char buffer[16] = {0};
+    AES_KEY aes;
+    if (AES_set_encrypt_key(key, key_length * 8, &aes) < 0)
+    {
+        return NULL;
+    }
+    AES_ecb_encrypt(buffer, buffer, &aes, AES_ENCRYPT);
+    char *auth_key = create_binary_hex(buffer, sizeof(buffer));
+    return auth_key;
+}
+
+struct macsec_sonic_data
+{
+    struct driver_wired_common_data common;
+
+    const char * ifname;
+    sonic_db_handle sonic_mamager;
+};
+
+static void *macsec_sonic_wpa_init(void *ctx, const char *ifname)
+{
+    struct macsec_sonic_data *drv;
+
+    drv = os_zalloc(sizeof(*drv));
+    if (!drv)
+        return NULL;
+
+    if (driver_wired_init_common(&drv->common, ifname, ctx) < 0)
+    {
+        os_free(drv);
+        return NULL;
+    }
+
+    drv->ifname = ifname;
+    drv->sonic_mamager = sonic_db_get_manager();
+
+    ENTER_LOG;
+    return drv;
+}
+
+static void macsec_sonic_wpa_deinit(void *priv)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    ENTER_LOG;
+
+    driver_wired_deinit_common(&drv->common);
+    os_free(drv);
+}
+
+static int macsec_sonic_macsec_init(void *priv, struct macsec_init_params *params)
+{
+    struct macsec_sonic_data *drv = priv;
+    ENTER_LOG;
+
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"enable", "false"},
+        {"cipher_suite" , "GCM-AES-128"}, // Default cipher suite
+    };
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_PORT_TABLE_NAME,
+        drv->ifname,
+        PAIR_ARRAY(pairs));
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        const struct sonic_db_name_value_pair pairs[] = 
+        {
+            {"state", "ok"}
+        };
+        ret = sonic_db_wait(
+            drv->sonic_mamager,
+            STATE_DB,
+            STATE_MACSEC_PORT_TABLE_NAME,
+            SET_COMMAND,
+            drv->ifname,
+            PAIR_ARRAY(pairs));
+    }
+    return ret;
+}
+
+static int macsec_sonic_macsec_deinit(void *priv)
+{
+    struct macsec_sonic_data *drv = priv;
+    ENTER_LOG;
+
+    int ret = sonic_db_del(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_PORT_TABLE_NAME,
+        drv->ifname);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        ret = sonic_db_wait(
+            drv->sonic_mamager,
+            STATE_DB,
+            STATE_MACSEC_PORT_TABLE_NAME,
+            DEL_COMMAND,
+            drv->ifname,
+            PAIR_EMPTY);
+    }
+    return ret;
+}
+
+static int macsec_sonic_get_capability(void *priv, enum macsec_cap *cap)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    ENTER_LOG;
+
+    *cap = MACSEC_CAP_INTEG_AND_CONF;
+
+    return 0;
+}
+
+/**
+ * macsec_sonic_enable_protect_frames - Set protect frames status
+ * @priv: Private driver interface data
+ * @enabled: TRUE = protect frames enabled
+ *           FALSE = protect frames disabled
+ * Returns: 0 on success, -1 on failure (or if not supported)
+ */
+static int macsec_sonic_enable_protect_frames(void *priv, Boolean enabled)
+{
+    struct macsec_sonic_data *drv = priv;
+    PRINT_LOG("%s", enabled ? "TRUE" : "FALSE");
+
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"enable_protect", enabled ? "true" : "false"}
+    };
+    return sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_PORT_TABLE_NAME,
+        drv->ifname,
+        PAIR_ARRAY(pairs));
+}
+
+/**
+ * macsec_sonic_enable_encrypt - Set protect frames status
+ * @priv: Private driver interface data
+ * @enabled: TRUE = protect frames enabled
+ *           FALSE = protect frames disabled
+ * Returns: 0 on success, -1 on failure (or if not supported)
+ */
+static int macsec_sonic_enable_encrypt(void *priv, Boolean enabled)
+{
+    struct macsec_sonic_data *drv = priv;
+    PRINT_LOG("%s", enabled ? "TRUE" : "FALSE");
+
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"enable_encrypt", enabled ? "true" : "false"}
+    };
+    return sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_PORT_TABLE_NAME,
+        drv->ifname,
+        PAIR_ARRAY(pairs));
+}
+
+/**
+ * macsec_sonic_set_replay_protect - Set replay protect status and window size
+ * @priv: Private driver interface data
+ * @enabled: TRUE = replay protect enabled
+ *           FALSE = replay protect disabled
+ * @window: replay window size, valid only when replay protect enabled
+ * Returns: 0 on success, -1 on failure (or if not supported)
+ */
+static int macsec_sonic_set_replay_protect(void *priv, Boolean enabled,
+                                           u32 window)
+{
+    struct macsec_sonic_data *drv = priv;
+    PRINT_LOG("%s %u", enabled ? "TRUE" : "FALSE", window);
+
+    char * buffer = create_buffer("%u", window);
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"enable_replay_protect", enabled ? "true" : "false"},
+        {"replay_window", buffer}
+    };
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_PORT_TABLE_NAME,
+        drv->ifname,
+        PAIR_ARRAY(pairs));
+    free(buffer);
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_set_current_cipher_suite - Set current cipher suite
+ * @priv: Private driver interface data
+ * @cs: EUI64 identifier
+ * Returns: 0 on success, -1 on failure (or if not supported)
+ */
+static int macsec_sonic_set_current_cipher_suite(void *priv, u64 cs)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    const char * cipher_suite = NULL;
+    if (cs == CS_ID_GCM_AES_128)
+    {
+        cipher_suite = "GCM-AES-128";
+    }
+    else if (cs == CS_ID_GCM_AES_256)
+    {
+        cipher_suite = "GCM-AES-256";
+    }
+    else
+    {
+        return SONIC_DB_FAIL;
+    }
+    PRINT_LOG("%s(%016" PRIx64 ")", cipher_suite, cs);
+
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"cipher_suite", cipher_suite},
+    };
+    return sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_PORT_TABLE_NAME,
+        drv->ifname,
+        PAIR_ARRAY(pairs));
+}
+
+/**
+ * macsec_sonic_enable_controlled_port - Set controlled port status
+ * @priv: Private driver interface data
+ * @enabled: TRUE = controlled port enabled
+ *           FALSE = controlled port disabled
+ * Returns: 0 on success, -1 on failure (or if not supported)
+ */
+static int macsec_sonic_enable_controlled_port(void *priv, Boolean enabled)
+{
+    struct macsec_sonic_data *drv = priv;
+    PRINT_LOG("%s", enabled ? "TRUE" : "FALSE");
+
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"enable", enabled ? "true" : "false"}
+    };
+    return sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_PORT_TABLE_NAME,
+        drv->ifname,
+        PAIR_ARRAY(pairs));
+}
+
+/**
+ * macsec_sonic_get_receive_lowest_pn - Get receive lowest PN
+ * @priv: Private driver interface data
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure (or if not supported)
+ */
+static int macsec_sonic_get_receive_lowest_pn(void *priv, struct receive_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    unsigned long long pn = 1;
+    int ret = sonic_db_get_counter(
+        drv->sonic_mamager,
+        COUNTERS_TABLE,
+        key,
+        "SAI_MACSEC_SA_ATTR_MINIMUM_XPN",
+        &pn);
+    PRINT_LOG("SA %s PN %llu", key, pn);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        sa->next_pn = pn;
+    }
+    free(key);
+    return ret;
+}
+
+/**
+ * macsec_sonic_set_receive_lowest_pn - Set receive lowest PN
+ * @priv: Private driver interface data
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure (or if not supported)
+ */
+static int macsec_sonic_set_receive_lowest_pn(void *priv, struct receive_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    PRINT_LOG("%s - %u", key, sa->next_pn);
+    char * buffer = create_buffer("%u", sa->next_pn);
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"lowest_acceptable_pn", buffer}
+    };
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_INGRESS_SA_TABLE_NAME,
+        key,
+        PAIR_ARRAY(pairs));
+    free(buffer);
+    free(key);
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_get_transmit_next_pn - Get transmit next PN
+ * @priv: Private driver interface data
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure (or if not supported)
+ */
+static int macsec_sonic_get_transmit_next_pn(void *priv, struct transmit_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    unsigned long long pn = 1;
+    int ret = sonic_db_get_counter(
+        drv->sonic_mamager,
+        COUNTERS_TABLE,
+        key,
+        "SAI_MACSEC_SA_ATTR_XPN",
+        &pn);
+    PRINT_LOG("SA %s PN %llu", key, pn);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        sa->next_pn = pn;
+    }
+    free(key);
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_set_transmit_next_pn - Set transmit next pn
+ * @priv: Private driver interface data
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure (or if not supported)
+ */
+static int macsec_sonic_set_transmit_next_pn(void *priv, struct transmit_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    PRINT_LOG("%s - %u", key, sa->next_pn);
+    char * buffer = create_buffer("%u", sa->next_pn);
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"init_pn", buffer}
+    };
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_EGRESS_SA_TABLE_NAME,
+        key,
+        PAIR_ARRAY(pairs));
+    free(buffer);
+    free(key);
+
+    return ret;
+}
+
+#define SCISTR MACSTR "::%hx"
+#define SCI2STR(addr, port) MAC2STR(addr), htons(port)
+
+/**
+ * macsec_sonic_create_receive_sc - Create secure channel for receiving
+ * @priv: Private driver interface data
+ * @sc: secure channel
+ * @sci_addr: secure channel identifier - address
+ * @sci_port: secure channel identifier - port
+ * @conf_offset: confidentiality offset (0, 30, or 50)
+ * @validation: frame validation policy (0 = Disabled, 1 = Checked,
+ *	2 = Strict)
+ * Returns: 0 on success, -1 on failure (or if not supported)
+ */
+static int macsec_sonic_create_receive_sc(void *priv, struct receive_sc *sc,
+                                          unsigned int conf_offset,
+                                          int validation)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SC_KEY(drv->ifname, sc, APP_DB_SEPARATOR);
+    PRINT_LOG("%s (conf_offset=%u validation=%d)",
+        key,
+        conf_offset,
+        validation);
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"ssci", ""},
+    };
+    // TODO 
+    // Validation
+    // OFFSET
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_INGRESS_SC_TABLE_NAME,
+        key,
+        PAIR_ARRAY(pairs));
+    free(key);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        const struct sonic_db_name_value_pair pairs[] = 
+        {
+            {"state", "ok"}
+        };
+        char * key = CREATE_SC_KEY(drv->ifname, sc, STATE_DB_SEPARATOR);
+        ret = sonic_db_wait(
+            drv->sonic_mamager,
+            STATE_DB,
+            STATE_MACSEC_INGRESS_SC_TABLE_NAME,
+            SET_COMMAND,
+            key,
+            PAIR_ARRAY(pairs));
+        free(key);
+    }
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_delete_receive_sc - Delete secure connection for receiving
+ * @priv: private driver interface data from init()
+ * @sc: secure channel
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_delete_receive_sc(void *priv, struct receive_sc *sc)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SC_KEY(drv->ifname, sc, APP_DB_SEPARATOR);
+    PRINT_LOG("%s", key);
+    int ret = sonic_db_del(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_INGRESS_SC_TABLE_NAME,
+        key);
+    free(key);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        char * key = CREATE_SC_KEY(drv->ifname, sc, STATE_DB_SEPARATOR);
+        ret = sonic_db_wait(
+            drv->sonic_mamager,
+            STATE_DB,
+            STATE_MACSEC_INGRESS_SC_TABLE_NAME,
+            DEL_COMMAND,
+            key,
+            PAIR_EMPTY);
+        free(key);
+    }
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_create_receive_sa - Create secure association for receive
+ * @priv: private driver interface data from init()
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_create_receive_sa(void *priv, struct receive_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    char * sak_id = create_binary_hex(&sa->pkey->key_identifier, sizeof(sa->pkey->key_identifier));
+    char * sak = create_binary_hex(sa->pkey->key, sa->pkey->key_len);
+    char * pn = create_buffer("%u", sa->next_pn);
+    char * auth_key = create_auth_key(sa->pkey->key, sa->pkey->key_len);
+    PRINT_LOG("%s (enable_receive=%d next_pn=%u) %s %s",
+        key,
+        sa->enable_receive,
+        sa->next_pn,
+        sak_id,
+        sak);
+
+    // TODO
+    // SALT
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"active", "false"},
+        {"sak", sak},
+        {"auth_key", auth_key},
+        {"lowest_acceptable_pn", pn},
+        {"salt", ""}
+    };
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_INGRESS_SA_TABLE_NAME,
+        key,
+        PAIR_ARRAY(pairs));
+    free(key);
+    free(sak_id);
+    free(sak);
+    free(pn);
+    free(auth_key);
+    return ret;
+}
+
+/**
+ * macsec_sonic_delete_receive_sa - Delete secure association for receive
+ * @priv: private driver interface data from init()
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_delete_receive_sa(void *priv, struct receive_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    PRINT_LOG("%s", key);
+    int ret = sonic_db_del(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_INGRESS_SA_TABLE_NAME,
+        key);
+    free(key);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        char * key = CREATE_SA_KEY(drv->ifname, sa, STATE_DB_SEPARATOR);
+        ret = sonic_db_wait(
+            drv->sonic_mamager,
+            STATE_DB,
+            STATE_MACSEC_INGRESS_SA_TABLE_NAME,
+            DEL_COMMAND,
+            key,
+            PAIR_EMPTY);
+        free(key);
+    }
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_enable_receive_sa - Enable the SA for receive
+ * @priv: private driver interface data from init()
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_enable_receive_sa(void *priv, struct receive_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    PRINT_LOG("%s", key);
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"active", "true"},
+    };
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_INGRESS_SA_TABLE_NAME,
+        key,
+        PAIR_ARRAY(pairs));
+    free(key);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        const struct sonic_db_name_value_pair pairs[] = 
+        {
+            {"state", "ok"},
+        };
+        char * key = CREATE_SA_KEY(drv->ifname, sa, STATE_DB_SEPARATOR);
+        ret = sonic_db_wait(
+            drv->sonic_mamager,
+            STATE_DB,
+            STATE_MACSEC_INGRESS_SA_TABLE_NAME,
+            SET_COMMAND,
+            key,
+            PAIR_ARRAY(pairs));
+        free(key);
+    }
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_disable_receive_sa - Disable SA for receive
+ * @priv: private driver interface data from init()
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_disable_receive_sa(void *priv, struct receive_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    PRINT_LOG("%s", key);
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"active", "false"},
+    };
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_INGRESS_SA_TABLE_NAME,
+        key,
+        PAIR_ARRAY(pairs));
+    free(key);
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_create_transmit_sc - Create secure connection for transmit
+ * @priv: private driver interface data from init()
+ * @sc: secure channel
+ * @conf_offset: confidentiality offset
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_create_transmit_sc(
+    void *priv, struct transmit_sc *sc,
+    unsigned int conf_offset)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SC_KEY(drv->ifname, sc, APP_DB_SEPARATOR);
+    PRINT_LOG("%s (conf_offset=%u)",
+        key,
+        conf_offset);
+    // TODO 
+    // Validation
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"ssci", ""},
+        {"encoding_an", "0"},
+    };
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_EGRESS_SC_TABLE_NAME,
+        key,
+        PAIR_ARRAY(pairs));
+    free(key);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        const struct sonic_db_name_value_pair pairs[] = 
+        {
+            {"state", "ok"},
+        };
+        char * key = CREATE_SC_KEY(drv->ifname, sc, STATE_DB_SEPARATOR);
+        ret = sonic_db_wait(
+            drv->sonic_mamager,
+            STATE_DB,
+            STATE_MACSEC_EGRESS_SC_TABLE_NAME,
+            SET_COMMAND,
+            key,
+            PAIR_ARRAY(pairs));
+        free(key);
+    }
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_delete_transmit_sc - Delete secure connection for transmit
+ * @priv: private driver interface data from init()
+ * @sc: secure channel
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_delete_transmit_sc(void *priv, struct transmit_sc *sc)
+{
+
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SC_KEY(drv->ifname, sc, APP_DB_SEPARATOR);
+    PRINT_LOG("%s", key);
+    int ret = sonic_db_del(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_EGRESS_SC_TABLE_NAME,
+        key);
+    free(key);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        char * key = CREATE_SC_KEY(drv->ifname, sc, STATE_DB_SEPARATOR);
+        ret = sonic_db_wait(
+            drv->sonic_mamager,
+            STATE_DB,
+            STATE_MACSEC_EGRESS_SC_TABLE_NAME,
+            DEL_COMMAND,
+            key,
+            PAIR_EMPTY);
+        free(key);
+    }
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_create_transmit_sa - Create secure association for transmit
+ * @priv: private driver interface data from init()
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_create_transmit_sa(void *priv, struct transmit_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    char * sak_id = create_binary_hex(&sa->pkey->key_identifier, sizeof(sa->pkey->key_identifier));
+    char * sak = create_binary_hex(sa->pkey->key, sa->pkey->key_len);
+    char * pn = create_buffer("%u", sa->next_pn);
+    char * auth_key = create_auth_key(sa->pkey->key, sa->pkey->key_len);
+    PRINT_LOG("%s (enable_receive=%d next_pn=%u) %s %s",
+        key,
+        sa->enable_transmit,
+        sa->next_pn,
+        sak_id,
+        sak);
+
+    // TODO
+    // SALT
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"sak", sak},
+        {"auth_key", auth_key},
+        {"init_pn", pn},
+        {"salt", ""}
+    };
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_EGRESS_SA_TABLE_NAME,
+        key,
+        PAIR_ARRAY(pairs));
+    free(key);
+    free(sak_id);
+    free(sak);
+    free(pn);
+    free(auth_key);
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_delete_transmit_sa - Delete secure association for transmit
+ * @priv: private driver interface data from init()
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_delete_transmit_sa(void *priv, struct transmit_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    PRINT_LOG("%s", key);
+    int ret = sonic_db_del(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_EGRESS_SA_TABLE_NAME,
+        key);
+    free(key);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        char * key = CREATE_SA_KEY(drv->ifname, sa, STATE_DB_SEPARATOR);
+        ret = sonic_db_wait(
+            drv->sonic_mamager,
+            STATE_DB,
+            STATE_MACSEC_EGRESS_SA_TABLE_NAME,
+            DEL_COMMAND,
+            key,
+            PAIR_EMPTY);
+        free(key);
+    }
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_enable_transmit_sa - Enable SA for transmit
+ * @priv: private driver interface data from init()
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_enable_transmit_sa(void *priv, struct transmit_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SC_KEY(drv->ifname, sa->sc, APP_DB_SEPARATOR);
+    PRINT_LOG("%s", key);
+    char * encoding_an = create_buffer("%u", sa->an);
+    const struct sonic_db_name_value_pair pairs[] = 
+    {
+        {"encoding_an", encoding_an},
+    };
+    int ret = sonic_db_set(
+        drv->sonic_mamager,
+        APPL_DB,
+        APP_MACSEC_EGRESS_SC_TABLE_NAME,
+        key,
+        PAIR_ARRAY(pairs));
+    free(key);
+    if (ret == SONIC_DB_SUCCESS)
+    {
+        const struct sonic_db_name_value_pair pairs[] = 
+        {
+            {"state", "ok"},
+        };
+        char * key = CREATE_SA_KEY(drv->ifname, sa, STATE_DB_SEPARATOR);
+        ret = sonic_db_wait(
+            drv->sonic_mamager,
+            STATE_DB,
+            STATE_MACSEC_EGRESS_SA_TABLE_NAME,
+            SET_COMMAND,
+            key,
+            PAIR_ARRAY(pairs));
+        free(key);
+    }
+    free(encoding_an);
+
+    return ret;
+}
+
+/**
+ * macsec_sonic_disable_transmit_sa - Disable SA for transmit
+ * @priv: private driver interface data from init()
+ * @sa: secure association
+ * Returns: 0 on success, -1 on failure
+ */
+static int macsec_sonic_disable_transmit_sa(void *priv, struct transmit_sa *sa)
+{
+    struct macsec_sonic_data *drv = priv;
+
+    char * key = CREATE_SA_KEY(drv->ifname, sa, APP_DB_SEPARATOR);
+    PRINT_LOG("%s", key);
+    free(key);
+
+    return SONIC_DB_SUCCESS;
+}
+
+static int macsec_sonic_status(void *priv, char *buf, size_t buflen)
+{
+    struct macsec_sonic_data *drv = priv;
+    int res;
+    char *pos, *end;
+
+    pos = buf;
+    end = buf + buflen;
+
+    res = os_snprintf(pos, end - pos,
+                      "ifname=%s\n",
+                      drv->ifname);
+    if (os_snprintf_error(end - pos, res))
+        return pos - buf;
+    pos += res;
+
+    return pos - buf;
+}
+
+const struct wpa_driver_ops wpa_driver_macsec_sonic_ops = {
+    .name = "macsec_sonic",
+    .desc = "MACsec Ethernet driver for SONiC",
+    .get_ssid = driver_wired_get_ssid,
+    .get_bssid = driver_wired_get_bssid,
+    .get_capa = driver_wired_get_capa,
+    .init = macsec_sonic_wpa_init,
+    .deinit = macsec_sonic_wpa_deinit,
+
+    .macsec_init = macsec_sonic_macsec_init,
+    .macsec_deinit = macsec_sonic_macsec_deinit,
+    .macsec_get_capability = macsec_sonic_get_capability,
+    .enable_protect_frames = macsec_sonic_enable_protect_frames,
+    .enable_encrypt = macsec_sonic_enable_encrypt,
+    .set_replay_protect = macsec_sonic_set_replay_protect,
+    .set_current_cipher_suite = macsec_sonic_set_current_cipher_suite,
+    .enable_controlled_port = macsec_sonic_enable_controlled_port,
+    .get_receive_lowest_pn = macsec_sonic_get_receive_lowest_pn,
+    .set_receive_lowest_pn = macsec_sonic_set_receive_lowest_pn,
+    .get_transmit_next_pn = macsec_sonic_get_transmit_next_pn,
+    .set_transmit_next_pn = macsec_sonic_set_transmit_next_pn,
+    .create_receive_sc = macsec_sonic_create_receive_sc,
+    .delete_receive_sc = macsec_sonic_delete_receive_sc,
+    .create_receive_sa = macsec_sonic_create_receive_sa,
+    .delete_receive_sa = macsec_sonic_delete_receive_sa,
+    .enable_receive_sa = macsec_sonic_enable_receive_sa,
+    .disable_receive_sa = macsec_sonic_disable_receive_sa,
+    .create_transmit_sc = macsec_sonic_create_transmit_sc,
+    .delete_transmit_sc = macsec_sonic_delete_transmit_sc,
+    .create_transmit_sa = macsec_sonic_create_transmit_sa,
+    .delete_transmit_sa = macsec_sonic_delete_transmit_sa,
+    .enable_transmit_sa = macsec_sonic_enable_transmit_sa,
+    .disable_transmit_sa = macsec_sonic_disable_transmit_sa,
+
+    .status = macsec_sonic_status,
+};
diff --git a/src/drivers/drivers.c b/src/drivers/drivers.c
index e95df6d..1eb5c68 100644
--- a/src/drivers/drivers.c
+++ b/src/drivers/drivers.c
@@ -34,6 +34,9 @@ const struct wpa_driver_ops *const wpa_drivers[] =
 #ifdef CONFIG_DRIVER_WIRED
 	&wpa_driver_wired_ops,
 #endif /* CONFIG_DRIVER_WIRED */
+#ifdef CONFIG_DRIVER_MACSEC_SONIC
+	&wpa_driver_macsec_sonic_ops,
+#endif /* CONFIG_DRIVER_MACSEC_SONIC */
 #ifdef CONFIG_DRIVER_MACSEC_LINUX
 	&wpa_driver_macsec_linux_ops,
 #endif /* CONFIG_DRIVER_MACSEC_LINUX */
diff --git a/src/drivers/drivers.mak b/src/drivers/drivers.mak
index 442c59c..cd2ee96 100644
--- a/src/drivers/drivers.mak
+++ b/src/drivers/drivers.mak
@@ -18,6 +18,16 @@ DRV_OBJS += ../src/drivers/driver_wired.o
 NEED_DRV_WIRED_COMMON=1
 endif
 
+ifdef CONFIG_DRIVER_MACSEC_SONIC
+DRV_CFLAGS += -DCONFIG_DRIVER_MACSEC_SONIC
+DRV_OBJS += ../src/drivers/driver_macsec_sonic.o
+DRV_OBJS += ../src/drivers/sonic_operators.o
+DRV_LIBS += -lswsscommon -lstdc++
+NEED_DRV_WIRED_COMMON=1
+NEED_LIBNL=y
+CONFIG_LIBNL3_ROUTE=y
+endif
+
 ifdef CONFIG_DRIVER_MACSEC_LINUX
 DRV_CFLAGS += -DCONFIG_DRIVER_MACSEC_LINUX
 DRV_OBJS += ../src/drivers/driver_macsec_linux.o
diff --git a/src/drivers/drivers.mk b/src/drivers/drivers.mk
index 599a0b5..b09a6a2 100644
--- a/src/drivers/drivers.mk
+++ b/src/drivers/drivers.mk
@@ -18,6 +18,16 @@ DRV_OBJS += src/drivers/driver_wired.c
 NEED_DRV_WIRED_COMMON=1
 endif
 
+ifdef CONFIG_DRIVER_MACSEC_SONIC
+DRV_CFLAGS += -DCONFIG_DRIVER_MACSEC_SONIC
+DRV_OBJS += src/drivers/driver_macsec_sonic.c
+DRV_OBJS += src/drivers/sonic_operators.cpp
+DRV_LIBS += -lswsscommon -lstdc++
+NEED_DRV_WIRED_COMMON=1
+CONFIG_LIBNL3_ROUTE=y
+NEED_LIBNL=y
+endif
+
 ifdef CONFIG_DRIVER_MACSEC_LINUX
 DRV_CFLAGS += -DCONFIG_DRIVER_MACSEC_LINUX
 DRV_OBJS += src/drivers/driver_macsec_linux.c
diff --git a/src/drivers/sonic_operators.cpp b/src/drivers/sonic_operators.cpp
new file mode 100644
index 0000000..69e9c91
--- /dev/null
+++ b/src/drivers/sonic_operators.cpp
@@ -0,0 +1,507 @@
+#include "sonic_operators.h"
+
+#include <swss/schema.h>
+#include <swss/table.h>
+#include <swss/producerstatetable.h>
+#include <swss/dbconnector.h>
+#include <swss/select.h>
+#include <swss/subscriberstatetable.h>
+
+#include <vector>
+#include <map>
+#include <algorithm>
+#include <iterator>
+#include <deque>
+#include <memory>
+#include <iostream>
+#include <sstream>
+#include <thread>
+#include <chrono>
+
+// select() function timeout retry time, in millisecond
+constexpr int SELECT_TIMEOUT = 2000;
+
+// Retry times to counter db
+constexpr unsigned int RETRY_TIMES = 20;
+
+// Retry interval to counter db, in millisecond
+constexpr unsigned int RETRY_INTERVAL = 100;
+
+class select_guard
+{
+private:
+    swss::Selectable * m_selectable;
+    swss::Select * m_selector;
+public:
+    select_guard(swss::Selectable * selectable, swss::Select * selector) :
+        m_selectable(selectable),
+        m_selector(selector)
+    {
+        if (m_selector != nullptr && m_selectable != nullptr)
+        {
+            m_selector->addSelectable(m_selectable);
+        }
+    }
+
+    ~select_guard()
+    {
+        if (m_selector != nullptr && m_selectable != nullptr)
+        {
+            m_selector->removeSelectable(m_selectable);
+        }
+    }
+};
+
+class sonic_db_manager{
+private:
+    swss::DBConnector m_app_db;
+    swss::DBConnector m_state_db;
+    swss::DBConnector m_counters_db;
+
+    std::map<std::string, swss::Table> m_tables_in_counter_db;
+    std::map<std::string, swss::ProducerStateTable> m_producer_state_tables_in_app_db;
+    std::map<std::string, swss::SubscriberStateTable> m_subscriber_state_tables_in_state_db;
+    std::map<std::string, swss::Table> m_tables_in_state_db;
+
+    swss::Select m_selector;
+
+    template<typename TableMap>
+    auto & get_table(TableMap & tables, swss::DBConnector & db, const std::string & table_name)
+    {
+        return tables.emplace(
+                std::piecewise_construct,
+                std::forward_as_tuple(table_name),
+                std::forward_as_tuple(&db, table_name)).first->second;
+    }
+
+    std::string get_counter_id(const std::string & obj_key)
+    {
+        std::vector<swss::FieldValueTuple> temp;
+        auto & map_table = get_table(m_tables_in_counter_db, m_counters_db, COUNTERS_MACSEC_NAME_MAP);
+        if (!map_table.get("", temp))
+        {
+            return "";
+        }
+        auto id = std::find_if(
+            temp.begin(),
+            temp.end(),
+            [&](const swss::FieldValueTuple & fvt){
+                return fvField(fvt) == obj_key;
+            });
+        if (id == temp.end())
+        {
+            return "";
+        }
+        return id->second;
+    }
+
+    bool meet_expectation(
+        const std::string & op,
+        const sonic_db_name_value_pair * pairs,
+        unsigned int pair_count,
+        const swss::KeyOpFieldsValuesTuple & entry) const
+    {
+        if (op.empty() || op != kfvOp(entry))
+        {
+            return false;
+        }
+        if (pairs == nullptr || pair_count == 0)
+        {
+            if (op == DEL_COMMAND)
+            {
+                return true;
+            }
+            else
+            {
+                return !kfvFieldsValues(entry).empty();
+            }
+            
+        }
+        auto values = kfvFieldsValues(entry);
+        for (unsigned int i = 0; i < pair_count; i++)
+        {
+            if (pairs[i].name == nullptr)
+            {
+                continue;
+            }
+            auto value = std::find_if(
+                values.begin(),
+                values.end(),
+                [&](const swss::FieldValueTuple & fvt)
+                {
+                    return pairs[i].name == fvField(fvt);
+                });
+            if (
+                (value == values.end())
+                || (
+                    (pairs[i].value != nullptr)
+                    && (value->second != pairs[i].value)
+                    )
+                )
+            {
+                return false;
+            }
+        }
+        return true;
+    }
+
+public:
+    sonic_db_manager():
+        m_app_db("APPL_DB", 0),
+        m_state_db("STATE_DB", 0),
+        m_counters_db("COUNTERS_DB", 0)
+        {
+        }
+
+    int set(
+        int db_id,
+        const std::string & table_name,
+        const std::string & key,
+        const struct sonic_db_name_value_pair * pairs,
+        unsigned int pair_count)
+    {
+        if (db_id == APPL_DB)
+        {
+            auto & table = get_table(m_producer_state_tables_in_app_db, m_app_db, table_name);
+            std::vector<swss::FieldValueTuple> values;
+            if (pairs)
+            {
+                std::transform(
+                    pairs,
+                    pairs + pair_count,
+                    std::back_inserter(values),
+                    [](const sonic_db_name_value_pair & pair)
+                    {
+                        return std::make_pair(pair.name, pair.value ? pair.value : "");
+                    });
+            }
+            table.set(key, values);
+            return SONIC_DB_SUCCESS;
+        }
+        else
+        {
+            return SONIC_DB_FAIL;
+        }
+    }
+
+    int get(
+        int db_id,
+        const std::string & table_name,
+        const std::string & key,
+        std::vector<swss::FieldValueTuple> & pairs)
+    {
+        pairs.clear();
+        if (db_id == STATE_DB)
+        {
+            auto & table = get_table(m_tables_in_state_db, m_state_db, table_name);
+            if(!table.get(key, pairs))
+            {
+                return SONIC_DB_FAIL;
+            }
+            return SONIC_DB_SUCCESS;
+        }
+        else
+        {
+            return SONIC_DB_FAIL;
+        }
+    }
+
+    int get(
+        int db_id,
+        const std::string & table_name,
+        const std::string & key,
+        struct sonic_db_name_value_pairs * pairs)
+    {
+        std::vector<swss::FieldValueTuple> result;
+        if (get(db_id, table_name, key, result) != SONIC_DB_SUCCESS)
+        {
+            return SONIC_DB_FAIL;
+        }
+        // Copy the query result to the output
+        pairs->pairs = 
+            reinterpret_cast<struct sonic_db_name_value_pair *>(
+                realloc(pairs->pairs, sizeof(sonic_db_name_value_pair) * result.size())
+            );
+        if (pairs->pairs == nullptr)
+        {
+            return SONIC_DB_FAIL;
+        }
+        for (size_t i = 0; i < result.size(); i++)
+        {
+            char * name = reinterpret_cast<char *>(malloc(result[i].first.length() + 1));
+            memcpy(name, result[i].first.data(), result[i].first.length() + 1);
+            pairs->pairs[pairs->pair_count].name = name;
+            char * value = reinterpret_cast<char *>(malloc(result[i].second.length() + 1));
+            memcpy(value, result[i].first.data(), result[i].second.length() + 1);
+            pairs->pairs[pairs->pair_count].value = value;
+        }
+        return SONIC_DB_SUCCESS;
+    }
+
+    int del(
+        int db_id,
+        const std::string & table_name,
+        const std::string & key)
+    {
+        if (db_id == APPL_DB)
+        {
+            auto & table = get_table(m_producer_state_tables_in_app_db, m_app_db, table_name);
+            table.del(key);
+            return SONIC_DB_SUCCESS;
+        }
+        else
+        {
+            return SONIC_DB_FAIL;
+        }
+    }
+
+    int wait(
+    int db_id,
+    const std::string & table_name,
+    const std::string & op,
+    const std::string & key,
+    const struct sonic_db_name_value_pair * pairs,
+    unsigned int pair_count)
+    {
+        // Subscribe the target table
+        swss::ConsumerTableBase * consumer = nullptr;
+        std::unique_ptr<select_guard> guarder;
+        if (db_id == STATE_DB)
+        {
+            consumer = &get_table(m_subscriber_state_tables_in_state_db, m_state_db, table_name);
+            guarder.reset(new select_guard(consumer, &m_selector));
+        }
+        else
+        {
+            return SONIC_DB_FAIL;
+        }
+        if (consumer == nullptr)
+        {
+            return SONIC_DB_FAIL;
+        }
+
+        // Proactively query the target table to avoid that 
+        // the target table was updated before the subscription
+        // which causes that the update cannot be fetched
+        swss::KeyOpFieldsValuesTuple result;
+        get(db_id, table_name, key, kfvFieldsValues(result));
+        kfvOp(result) = kfvFieldsValues(result).empty() ? DEL_COMMAND : SET_COMMAND;
+        if (meet_expectation(op, pairs, pair_count, result))
+        {
+            return SONIC_DB_SUCCESS;
+        }
+
+        // Fetch the update
+        int ret = 0;
+        while(true)
+        {
+            swss::Selectable *sel = nullptr;
+            ret = m_selector.select(&sel, SELECT_TIMEOUT);
+            if (ret == swss::Select::ERROR)
+            {
+                return SONIC_DB_FAIL;
+            }
+            if (ret == swss::Select::TIMEOUT)
+            {
+                return SONIC_DB_FAIL;
+            }
+            std::deque<swss::KeyOpFieldsValuesTuple> entries;
+            consumer->pops(entries);
+            for (auto & entry : entries)
+            {
+                if (meet_expectation(op, pairs, pair_count, entry))
+                {
+                    return SONIC_DB_SUCCESS;
+                }
+            }
+        };
+        return SONIC_DB_SUCCESS;
+    }
+
+    int get_counter(
+        const std::string & table_name,
+        const std::string & key,
+        const std::string & field,
+        unsigned long long * counter)
+    {
+        std::vector<swss::FieldValueTuple> result;
+        const std::string id = get_counter_id(key);
+        if (id.empty())
+        {
+            return SONIC_DB_FAIL;
+        }
+        // Find counter from counter db
+        auto & counter_table = get_table(m_tables_in_counter_db, m_counters_db, table_name);
+        auto retry_time = RETRY_TIMES;
+        while (retry_time -- > 0)
+        {
+            if (!counter_table.get(id, result))
+            {
+                std::this_thread::sleep_for(std::chrono::milliseconds(RETRY_INTERVAL));
+                continue;
+            }
+            auto value = std::find_if(
+                result.begin(),
+                result.end(),
+                [&](const swss::FieldValueTuple & fvt)
+                {
+                    return field == fvField(fvt);
+                });
+            if (value == result.end())
+            {
+                std::this_thread::sleep_for(std::chrono::milliseconds(RETRY_INTERVAL));
+                continue;
+            }
+            std::stringstream(fvValue(*value)) >> *counter;
+            return SONIC_DB_SUCCESS;
+        }
+        return SONIC_DB_FAIL;
+    }
+
+    int del_counter(
+        const std::string & table_name,
+        const std::string & key)
+    {
+        const std::string id = get_counter_id(key);
+        if (id.empty())
+        {
+            return SONIC_DB_FAIL;
+        }
+        if (m_tables_in_counter_db.erase(id) == 0)
+        {
+            return SONIC_DB_FAIL;
+        }
+        return SONIC_DB_SUCCESS;
+    }
+};
+
+sonic_db_handle sonic_db_get_manager()
+{
+    thread_local sonic_db_manager manager;
+    return &manager;
+}
+
+int sonic_db_set(
+    sonic_db_handle sonic_manager,
+    int db_id,
+    const char * table_name,
+    const char * key,
+    const struct sonic_db_name_value_pair * pairs,
+    unsigned int pair_count)
+{
+    sonic_db_manager * manager = reinterpret_cast<sonic_db_manager *>(sonic_manager);
+    if (manager == nullptr)
+    {
+        return SONIC_DB_FAIL;
+    }
+    return manager->set(db_id, table_name, key, pairs, pair_count);
+}
+
+int sonic_db_get(
+    sonic_db_handle sonic_manager,
+    int db_id,
+    const char * table_name,
+    const char * key,
+    struct sonic_db_name_value_pairs * pairs)
+{
+    sonic_db_manager * manager = reinterpret_cast<sonic_db_manager *>(sonic_manager);
+    if (manager == nullptr)
+    {
+        return SONIC_DB_FAIL;
+    }
+    return manager->get(db_id, table_name, key, pairs);
+}
+
+int sonic_db_del(
+    sonic_db_handle sonic_manager,
+    int db_id,
+    const char * table_name,
+    const char * key)
+{
+    sonic_db_manager * manager = reinterpret_cast<sonic_db_manager *>(sonic_manager);
+    if (manager == nullptr)
+    {
+        return SONIC_DB_FAIL;
+    }
+    return manager->del(db_id, table_name, key);
+}
+
+int sonic_db_wait(
+    sonic_db_handle sonic_manager,
+    int db_id,
+    const char * table,
+    const char * op,
+    const char * key,
+    const struct sonic_db_name_value_pair * pairs,
+    unsigned int pair_count)
+{
+    sonic_db_manager * manager = reinterpret_cast<sonic_db_manager *>(sonic_manager);
+    if (manager == nullptr)
+    {
+        return SONIC_DB_FAIL;
+    }
+    return manager->wait(db_id, table, op, key, pairs, pair_count);
+}
+
+int sonic_db_get_counter(
+    sonic_db_handle sonic_manager,
+    const char * table_name,
+    const char * key,
+    const char * field,
+    unsigned long long * counter)
+{
+    sonic_db_manager * manager = reinterpret_cast<sonic_db_manager *>(sonic_manager);
+    if (manager == nullptr)
+    {
+        return SONIC_DB_FAIL;
+    }
+    return manager->get_counter(table_name, key, field, counter);
+}
+
+int sonic_db_del_counter(
+    sonic_db_handle sonic_manager,
+    const char * table_name,
+    const char * key)
+{
+    sonic_db_manager * manager = reinterpret_cast<sonic_db_manager *>(sonic_manager);
+    if (manager == nullptr)
+    {
+        return SONIC_DB_FAIL;
+    }
+    return manager->del_counter(table_name, key);
+}
+
+
+struct sonic_db_name_value_pairs * sonic_db_malloc_name_value_pairs()
+{
+    struct sonic_db_name_value_pairs * pairs = reinterpret_cast<struct sonic_db_name_value_pairs *>(
+        malloc(sizeof(struct sonic_db_name_value_pairs))
+    );
+    if (pairs == nullptr)
+    {
+        return nullptr;
+    }
+    pairs->pair_count = 0;
+    pairs->pairs = UNSET_POINTER;
+    return reinterpret_cast<struct sonic_db_name_value_pairs *>(pairs);
+}
+
+void sonic_db_free_name_value_pairs(struct sonic_db_name_value_pairs * pairs)
+{
+    if (pairs == nullptr)
+    {
+        return;
+    }
+    for (unsigned int i = 0; i < pairs->pair_count; i++)
+    {
+        if (pairs->pairs[i].name != UNSET_POINTER)
+        {
+            free((char *)pairs->pairs[i].name);
+        }
+        if (pairs->pairs[i].value != UNSET_POINTER)
+        {
+            free((char *)pairs->pairs[i].value);
+        }
+    }
+    free(pairs);
+}
diff --git a/src/drivers/sonic_operators.h b/src/drivers/sonic_operators.h
new file mode 100644
index 0000000..a3be24d
--- /dev/null
+++ b/src/drivers/sonic_operators.h
@@ -0,0 +1,108 @@
+/*
+ * wpa_supplicant - 
+ * Copyright (c) 
+ *
+ * This software may be distributed under the terms of the BSD license.
+ * See README for more details.
+ */
+
+#ifndef SONIC_OPERATORS_H
+#define SONIC_OPERATORS_H
+
+// The following definitions should be moved to schema.h
+
+#define APP_MACSEC_PORT_TABLE_NAME          "MACSEC_PORT_TABLE"
+#define APP_MACSEC_EGRESS_SC_TABLE_NAME     "MACSEC_EGRESS_SC_TABLE"
+#define APP_MACSEC_INGRESS_SC_TABLE_NAME    "MACSEC_INGRESS_SC_TABLE"
+#define APP_MACSEC_EGRESS_SA_TABLE_NAME     "MACSEC_EGRESS_SA_TABLE"
+#define APP_MACSEC_INGRESS_SA_TABLE_NAME    "MACSEC_INGRESS_SA_TABLE"
+
+#define STATE_MACSEC_PORT_TABLE_NAME        "MACSEC_PORT_TABLE"
+#define STATE_MACSEC_INGRESS_SC_TABLE_NAME  "MACSEC_INGRESS_SC_TABLE"
+#define STATE_MACSEC_INGRESS_SA_TABLE_NAME  "MACSEC_INGRESS_SA_TABLE"
+#define STATE_MACSEC_EGRESS_SC_TABLE_NAME   "MACSEC_EGRESS_SC_TABLE"
+#define STATE_MACSEC_EGRESS_SA_TABLE_NAME   "MACSEC_EGRESS_SA_TABLE"
+
+#define COUNTERS_MACSEC_NAME_MAP            "COUNTERS_MACSEC_NAME_MAP"
+
+// End define
+
+#include <swss/schema.h>
+
+#define SONIC_DB_SUCCESS (0)
+#define SONIC_DB_FAIL    (-1)
+#define UNSET_POINTER    (NULL)
+
+struct sonic_db_name_value_pair
+{
+    const char * name;
+    const char * value;
+};
+
+struct sonic_db_name_value_pairs
+{
+    unsigned int pair_count;
+    struct sonic_db_name_value_pair * pairs;
+};
+
+typedef void * sonic_db_handle;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+sonic_db_handle sonic_db_get_manager();
+
+
+
+int sonic_db_set(
+    sonic_db_handle sonic_manager,
+    int db_id,
+    const char * table_name,
+    const char * key,
+    const struct sonic_db_name_value_pair * pairs,
+    unsigned int pair_count);
+
+int sonic_db_get(
+    sonic_db_handle sonic_manager,
+    int db_id,
+    const char * table_name,
+    const char * key,
+    struct sonic_db_name_value_pairs * pairs);
+
+int sonic_db_del(
+    sonic_db_handle sonic_manager,
+    int db_id,
+    const char * table_name,
+    const char * key);
+
+int sonic_db_wait(
+    sonic_db_handle sonic_manager,
+    int db_id,
+    const char * table,
+    const char * op,
+    const char * key,
+    const struct sonic_db_name_value_pair * pairs,
+    unsigned int pair_count);
+
+int sonic_db_get_counter(
+    sonic_db_handle sonic_manager,
+    const char * table_name,
+    const char * key,
+    const char * field,
+    unsigned long long * counter);
+
+int sonic_db_del_counter(
+    sonic_db_handle sonic_manager,
+    const char * table_name,
+    const char * key);
+
+struct sonic_db_name_value_pairs * sonic_db_malloc_name_value_pairs();
+
+void sonic_db_free_name_value_pairs(struct sonic_db_name_value_pairs * pairs);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif
diff --git a/wpa_supplicant/defconfig b/wpa_supplicant/defconfig
index cdfb197..160a701 100644
--- a/wpa_supplicant/defconfig
+++ b/wpa_supplicant/defconfig
@@ -79,6 +79,9 @@ CONFIG_DRIVER_WIRED=y
 # Driver interface for Linux MACsec drivers
 #CONFIG_DRIVER_MACSEC_LINUX=y
 
+# Driver interface for SONiC MACsec drivers
+#CONFIG_DRIVER_MACSEC_SONIC=y
+
 # Driver interface for the Broadcom RoboSwitch family
 #CONFIG_DRIVER_ROBOSWITCH=y
 
